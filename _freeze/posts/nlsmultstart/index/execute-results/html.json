{
  "hash": "9e4556a028afa74a0aa80959b785f56c",
  "result": {
    "markdown": "---\ntitle: Doing robust nls regression in R\ndescription: |\n  Fitting non-linear regressions with broom, purrr and nls.multstart\nauthor: Daniel Padfield\ndate: '2018-01-07'\ncategories:\n  - R\n  - nonlinear regression\n  - tidyverse\nimage: \"/posts/nlsmultstart/preview.png\"\n---\n\n\n## Introduction\n\nWith my research, I often use non-linear least squares regression to fit a model with biologically meaningful parameters to data. Specifically, I measure the thermal performance of phytoplankon growth, respiration and photosynthesis over a wide range of assay temperatures to see how the organisms are adapted to the temperatures they live at. \n\nThese thermal performance curves generally follow a unimodal shape and parameters for which are widely used in climate change research to predict whether organisms will be able to cope with increasing temperatures.\n\n![Example Thermal Performance Curve](TPC.png)\n\nThese curves can be modelled with a variety of equations, such as the Sharpe-Schoolfield equation, which I have log-transformed here:\n\n$$log(rate) = lnc + E(\\frac{1}{T_{c}} - \\frac{1}{kT}) - ln(1 + e^{E_h(\\frac{1}{kT_h} - \\frac{1}{kT})})$$\nwhere $lnc$ is a normalisation constant at a common temperature, $T_{c}$, $E$ is an activation energy that describes the rate of increase before the optimum temperature, $T_{opt}$. $k$ is Boltzmann's constant, $E_{h}$ is the deactivation energy that controls the decline in rate past the optimum temperature and $T_{h}$ is the temperature where, after the optimu, the rate is half of the maximal rate.\n\nSay I want to fit the same equation to 10, 50, or 100s of these curves. I could loop through a call to __nls()__, __nlsLM()__, or use __nlsList()__ from __nlme__. However, non-linear least squares regression in R is sensitive to the start parameters, meaning that different start parameters can give different \"best estimated parameters\". This becomes more likely when fitting more curves with only a single set of start parameters, where the variation in estimated parameter values is likely to be much larger. For example, some curves could have much higher rates ($lnc$), higher optimum temperatures (i.e. $T_{h}$) or have different values of temperature-dependence ($E$).\n\nTo combat this, I wrote an R package which allows for multiple start parameters for non-linear regression. I wrapped this method in an R package called [__nlsLoop__](https://github.com/padpadpadpad/nlsLoop) and submitted it to The Journal of Open Source Software. Everything was good with the world and I went to a Christmas party.\n\nThe next day, I had an epiphany surrounding the redundancies and needless complexities of my R package, withdrew my submission and rewrote the entire package in a weekend to give rise to a single function package, __nls.multstart::nls_multstart()__. Essentially since I first wrote __nlsLoop__ ~3 years ago I have realised that __broom__ and __purrr__ can do what I wrote clunkier functions to achieve. In contrast, [__nls.multstart__](https://github.com/padpadpadpad/nls.multstart) works perfectly with the tools of the __tidyverse__ to fit multiple models.\n\n\n## Multiple model fitting in practice\n\nLoad in all packages that are used in this analysis. Packages can be installed from GitHub using __devtools__.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load packages\nlibrary(nls.multstart)\nlibrary(ggplot2)\nlibrary(broom)\nlibrary(tidyverse)\nlibrary(nlstools)\n```\n:::\n\n\nWe can then load in the data and have a look at it using __glimpse()__. Here we shall use a dataset of thermal performance curves of metabolism of _Chlorella vulgaris_ from Padfield _et al._ 2016.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load in example data set\ndata(\"Chlorella_TRC\")\nglimpse(Chlorella_TRC)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 649\nColumns: 7\n$ curve_id    <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2…\n$ growth.temp <dbl> 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20…\n$ process     <chr> \"acclimation\", \"acclimation\", \"acclimation\", \"acclimation\"…\n$ flux        <chr> \"respiration\", \"respiration\", \"respiration\", \"respiration\"…\n$ temp        <dbl> 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 16, 19, 22…\n$ K           <dbl> 289.15, 292.15, 295.15, 298.15, 301.15, 304.15, 307.15, 31…\n$ ln.rate     <dbl> -2.06257833, -1.32437939, -0.95416807, -0.79443675, -0.182…\n```\n:::\n:::\n\n\nNext we define the Sharpe-Schoolfield equation discussed earlier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define the Sharpe-Schoolfield equation\nschoolfield_high <- function(lnc, E, Eh, Th, temp, Tc) {\n  Tc <- 273.15 + Tc\n  k <- 8.62e-5\n  boltzmann.term <- lnc + log(exp(E/k*(1/Tc - 1/temp)))\n  inactivation.term <- log(1/(1 + exp(Eh/k*(1/Th - 1/temp))))\n  return(boltzmann.term + inactivation.term)\n  }\n```\n:::\n\n\nThere are 60 curves in this dataset, 30 each of photosynthesis and respiration. The treatments are growth temperature (20, 23, 27, 30, 33 ºC) and adaptive process (acclimation or adaptation) that reflects the number of generations cultures were grown at each temperature.\n\nWe can see how __nls_multstart()__ works by subsetting the data for a single curve.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# subset dataset\nd_1 <- subset(Chlorella_TRC, curve_id == 1)\n# run nls_multstart\nfit <- nls_multstart(ln.rate ~ schoolfield_high(lnc, E, Eh, Th, temp = K, Tc = 20),\n                     data = d_1,\n                     iter = 500,\n                     start_lower = c(lnc = -10, E = 0.1, Eh = 0.2, Th = 285),\n                     start_upper = c(lnc = 10, E = 2, Eh = 5, Th = 330),\n                     supp_errors = 'Y',\n                     na.action = na.omit,\n                     lower = c(lnc = -10, E = 0, Eh = 0, Th = 0))\nfit\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNonlinear regression model\n  model: ln.rate ~ schoolfield_high(lnc, E, Eh, Th, temp = K, Tc = 20)\n   data: data\n     lnc        E       Eh       Th \n -1.3462   0.9877   4.3326 312.1887 \n residual sum-of-squares: 7.257\n\nNumber of iterations to convergence: 15 \nAchieved convergence tolerance: 1.49e-08\n```\n:::\n:::\n\n\n__nls_multstart()__ allows boundaries for each parameter to be set. A uniform distribution between these values is created and start values for each iteration of the fitting process are then picked randomly. The function returns the best available model by picking the model with the lowest AIC score. Additional info on the function can be found [here](https://github.com/padpadpadpad/nls.multstart) or by typing `?nls_multstart` into the R console.\n\nThis fit can then be \"tidied\" in various ways using the R package __broom__. Each different function in __broom__ returns a different set of information. __tidy()__ returns the estimated parameters, __augment()__ returns the predictions and __glance()__ returns information about the model such as the AIC score and whether the model has reached convergence. Confidence intervals of non-linear regression can also be estimated using __nlstools::confint2()__\n\nThe amazing thing about these tools is the ease at which they can then be used on multiple curves at once, an approach Hadley Wickham has previously [written about](https://blog.rstudio.com/2016/02/02/tidyr-0-4-0/). The approach nests the data based on grouping variables using __nest()__, then creates a list column of the best fit for each curve using __map()__.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# fit over each set of groupings\nfits <- Chlorella_TRC %>%\n  group_by(., flux, growth.temp, process, curve_id) %>%\n  nest() %>%\n  mutate(fit = purrr::map(data, ~ nls_multstart(ln.rate ~ schoolfield_high(lnc, E, Eh, Th, temp = K, Tc = 20),\n                                   data = .x,\n                                   iter = 1000,\n                                   start_lower = c(lnc = -10, E = 0.1, Eh = 0.2, Th = 285),\n                                   start_upper = c(lnc = 10, E = 2, Eh = 5, Th = 330),\n                                   supp_errors = 'Y',\n                                   na.action = na.omit,\n                                   lower = c(lnc = -10, E = 0, Eh = 0, Th = 0))))\n```\n:::\n\n\nIf you are confused, then you are not alone. This took me a long time to understand and I imagine there are still better ways for me to do it! However, to check it has worked, we can look at a single fit to check it looks ok. We can also look at `fits` to see that there is now a `fit` list column containing each of the non-linear fits for each combination of our grouping variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# look at a single fit\nsummary(fits$fit[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nFormula: ln.rate ~ schoolfield_high(lnc, E, Eh, Th, temp = K, Tc = 20)\n\nParameters:\n    Estimate Std. Error t value Pr(>|t|)    \nlnc  -1.3462     0.4656  -2.891   0.0202 *  \nE     0.9877     0.4521   2.185   0.0604 .  \nEh    4.3326     1.4878   2.912   0.0195 *  \nTh  312.1887     3.8782  80.499 6.32e-13 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.9524 on 8 degrees of freedom\n\nNumber of iterations to convergence: 19 \nAchieved convergence tolerance: 1.49e-08\n```\n:::\n\n```{.r .cell-code}\n# look at output object\nselect(fits, curve_id, data, fit)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nAdding missing grouping variables: `flux`, `growth.temp`, `process`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 60 × 6\n# Groups:   flux, growth.temp, process, curve_id [60]\n   flux        growth.temp process     curve_id data              fit   \n   <chr>             <dbl> <chr>          <dbl> <list>            <list>\n 1 respiration          20 acclimation        1 <tibble [12 × 3]> <nls> \n 2 respiration          20 acclimation        2 <tibble [12 × 3]> <nls> \n 3 respiration          23 acclimation        3 <tibble [12 × 3]> <nls> \n 4 respiration          27 acclimation        4 <tibble [9 × 3]>  <nls> \n 5 respiration          27 acclimation        5 <tibble [12 × 3]> <nls> \n 6 respiration          30 acclimation        6 <tibble [12 × 3]> <nls> \n 7 respiration          30 acclimation        7 <tibble [12 × 3]> <nls> \n 8 respiration          33 acclimation        8 <tibble [10 × 3]> <nls> \n 9 respiration          33 acclimation        9 <tibble [8 × 3]>  <nls> \n10 respiration          20 acclimation       10 <tibble [10 × 3]> <nls> \n# … with 50 more rows\n```\n:::\n:::\n\n\nThese fits can be cleaned up using the __broom__ functions and __purrr::map()__ to iterate over the grouping variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get summary info\ninfo <- fits %>%\n  mutate(., info = map(fit, glance)) %>%\n  unnest(info)\n\n# get params\nparams <- fits %>%\n  mutate(., params = map(fit, tidy)) %>%\n  unnest(params)\n  \n# get confidence intervals\nCI <- fits %>% \n  mutate(., CI = map(fit, function(x)data.frame(confint2(x)))) %>%\n  unnest(CI) %>%\n  select(-data, -fit) %>%\n  rename(., conf.low = `X2.5..`, conf.high = `X97.5..`) %>%\n  group_by(., curve_id) %>%\n  mutate(., term = c('lnc', 'E', 'Eh', 'Th')) %>%\n  ungroup()\n# merge parameters and CI estimates\nparams <- merge(params, CI, by = intersect(names(params), names(CI)))\n\n# get predictions\npreds <- fits %>%\n  mutate(., preds = map(fit, augment)) %>%\n  unnest(preds)\n```\n:::\n\n\nLooking at __info__ allows us to see if all the models converged.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nungroup(info) %>% select(., curve_id, logLik, AIC, BIC, deviance, df.residual)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 60 × 6\n   curve_id  logLik   AIC   BIC deviance df.residual\n      <dbl>   <dbl> <dbl> <dbl>    <dbl>       <int>\n 1        1 -14.0   38.0  40.4     7.26            8\n 2        2  -1.20  12.4  14.8     0.858           8\n 3        3  -7.39  24.8  27.2     2.41            8\n 4        4  -0.523 11.0  12.0     0.592           5\n 5        5 -10.8   31.7  34.1     4.29            8\n 6        6  -8.52  27.0  29.5     2.91            8\n 7        7  -1.29  12.6  15.0     0.871           8\n 8        8 -13.4   36.7  38.2     8.48            6\n 9        9   1.82   6.36  6.76    0.297           4\n10       10  -1.27  12.5  14.1     0.755           6\n# … with 50 more rows\n```\n:::\n:::\n\n\nWhen plotting non-linear fits, I prefer to have a smooth curve, even when there are not many points underlying the fit. This can be achieved by including `newdata` in the __augment()__ function and creating a higher resolution set of predictor values. \n\nHowever, when predicting for many different fits, it is not certain that each curve has the same range of predictor variables. We can get around this by setting the limits of each prediction by the __min()__ and __max()__ of the predictor variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# new data frame of predictions\nnew_preds <- Chlorella_TRC %>%\n  do(., data.frame(K = seq(min(.$K), max(.$K), length.out = 150), stringsAsFactors = FALSE))\n# max and min for each curve\nmax_min <- group_by(Chlorella_TRC, curve_id) %>%\n  summarise(., min_K = min(K), max_K = max(K), .groups = 'drop')\n\n# create new predictions\npreds2 <- fits %>%\n  mutate(preds = map(fit, augment, newdata = new_preds)) %>%\n  unnest(preds) %>%\n  merge(., max_min, by = 'curve_id') %>%\n  group_by(., curve_id) %>%\n  filter(., K > unique(min_K) & K < unique(max_K)) %>%\n  rename(., ln.rate = .fitted) %>%\n  ungroup()\n```\n:::\n\n\nThese can then be plotted using __ggplot2__.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot\nggplot() +\n  geom_point(aes(K - 273.15, ln.rate, col = flux), size = 2, Chlorella_TRC) +\n  geom_line(aes(K - 273.15, ln.rate, col = flux, group = curve_id), alpha = 0.5, preds2) +\n  facet_wrap(~ growth.temp + process, labeller = labeller(.multi_line = FALSE)) +\n  scale_colour_manual(values = c('green4', 'black')) +\n  theme_bw(base_size = 12, base_family = 'Helvetica') +\n  ylab('log Metabolic rate') +\n  xlab('Assay temperature (ºC)') +\n  theme(legend.position = c(0.9, 0.15))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot_many_fits-1.png){width=672}\n:::\n:::\n\n\nThe confidence intervals of each parameter for each curve fit can also be easily visualised.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot\nggplot(params, aes(col = flux)) +\n  geom_point(aes(curve_id, estimate)) +\n  facet_wrap(~ term, scale = 'free_x', ncol = 4) +\n  geom_linerange(aes(curve_id, ymin = conf.low, ymax = conf.high)) +\n  coord_flip() +\n  scale_color_manual(values = c('green4', 'black')) +\n  theme_bw(base_size = 12, base_family = 'Helvetica') +\n  theme(legend.position = 'top') +\n  xlab('curve') +\n  ylab('parameter estimate')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/confint_plot-1.png){width=672}\n:::\n:::\n\n\nThis method of modelling can be used for different data, different non-linear models (and linear models for that matter) and combined with the __tidyverse__ can make very useful visualisations.\n\nThe next stage of these curve fits is to try and better understand the uncertainty of these curve fits and their predictions. One approach to achieve this could be bootstrapping new datasets from the existing data. I hope to demonstrate how this could be done soon in another post.\n\n## References\n\n[1] Padfield, D., Yvon-durocher, G., Buckling, A., Jennings, S. & Yvon-durocher, G. (2016). Rapid evolution of metabolic traits explains thermal adaptation in phytoplankton. Ecology Letters, 19(2), 133-142.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}