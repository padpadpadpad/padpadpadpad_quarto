{
  "hash": "cdceda3833202a7473937a13015cb980",
  "result": {
    "markdown": "---\ntitle: rStrava and gganimate\ndescription: |\n  Animate your Strava activities in R using rStrava and gganimate\nauthor: Daniel Padfield\ndate: '2018-05-18'\ncategories: \n  - R\n  - strava\n  - gganimate\nimage: \"/posts/animate_rstrava/preview.png\"\n---\n\n\n\n\n## Getting started with rStrava\n\n**rStrava** is an R package that allows you to access data from Strava using the Strava API. Some of the functions of **rStrava** scrape data from the public Strava website but to access your own data you will need a Strava profile and an authentication token. Details on obtaining your unique token can be found on the [**rStrava**](https://github.com/fawda123/rStrava) GitHub In addition to this key, we use `rgbif::elevation()` to calculate the elevation of each route. This requires a Google API key which can be created here.\n\nGot a Strava authentication token? Got a Google API key? We are ready to create some animations! To create our animations, we use gganimate that requires ImageMagick to be installed.\n\n## Loading packages and defining tokens\n\nFirst load the packages that are used in the script and our Strava and Google authentication tokens. The `app_scope` argument in `strava_oauth()` has to be one of \"read\" , \"read_all\", \"profile:read_all\", \"profile:write\", \"activity:read\", \"activity:read_all\" or \"activity:write\". To access your activities, `activity:read_all` has to be included.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load packages ####\nlibrary(rStrava) # devtools::install_github('fawda123/rStrava')\nlibrary(gganimate)\nlibrary(tidyverse)\nlibrary(sp)\nlibrary(ggmap)\nlibrary(raster)\n\n# initial setup ####\n# Strava key\napp_name <- 'xxxx'\napp_client_id <- 'xxxxx'\napp_secret <- '\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"'\n\n# create strava token\nmy_token <- httr::config(token = strava_oauth(app_name, app_client_id, app_secret, app_scope = 'read_all,activity:read_all'))\n\n# Google elevation API key\nGoogleAPI <- 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'\n```\n:::\n\n\nA browser window should open at this point saying Authentication complete. Please close this page and return to R. This means everything is going well!\n\n\n::: {.cell}\n\n:::\n\n\n## Download your data\n\nWe can then download our personal activity data using the `rStrava::get_activity_list()`. This function needs your strava token and your strava athlete id. For example, my strava id is 2140248.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# download strava data\nmy_acts <- get_activity_list(my_token)\n\nlength(my_acts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1669\n```\n:::\n:::\n\n\nThis returns a large list of all your previous activities. Mine has 1028 previous entries. If you want to explore your list, you can use `View(my_acts)` in RStudio which opens the Data Viewer window.\n\n## Compile your data into \"tidy\" dataframe\n\n**rStrava** has a function that compiles the information stored in the output of `get_activity_list()` to a \"tidy\" dataframe, with one row for each activity. `compile_activities()` finds all the columns across all activities and returns `NA` when a column is not present in a given activity. This means that if HR was not measured across all your strava activities, the function will still work!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# compile activities into a tidy dataframe\nmy_acts <- compile_activities(my_acts)\n\n# have a look at the dataframe\ndplyr::glimpse(my_acts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,669\nColumns: 60\n$ achievement_count             <dbl> 5, 9, 12, 0, 0, 1, 11, 1, 23, 3, 2, 0, 0…\n$ athlete_count                 <dbl> 1, 1, 2, 1, 1, 1, 1, 1, 51, 1, 1, 1, 1, …\n$ athlete.id                    <chr> \"2140248\", \"2140248\", \"2140248\", \"214024…\n$ athlete.resource_state        <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ average_heartrate             <chr> \"127.8\", \"127.6\", \"123.8\", NA, \"127.4\", …\n$ average_speed                 <dbl> 21.9168, 26.2476, 24.0264, 27.1476, 17.5…\n$ average_temp                  <chr> \"10\", \"9\", \"9\", \"7\", \"3\", NA, NA, NA, NA…\n$ average_watts                 <dbl> 134.7, 156.7, 148.8, 101.1, 138.1, NA, N…\n$ comment_count                 <dbl> 1, 14, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 2, …\n$ commute                       <chr> \"FALSE\", \"FALSE\", \"FALSE\", \"FALSE\", \"FAL…\n$ device_watts                  <chr> \"FALSE\", \"FALSE\", \"FALSE\", \"FALSE\", \"FAL…\n$ display_hide_heartrate_option <chr> \"TRUE\", \"TRUE\", \"TRUE\", \"FALSE\", \"TRUE\",…\n$ distance                      <dbl> 22.3615, 27.7074, 42.3477, 5.7089, 5.639…\n$ elapsed_time                  <dbl> 3822, 3884, 6656, 757, 1158, 1923, 4469,…\n$ elev_high                     <dbl> 73.2, 146.2, 238.6, 118.2, 126.8, 75.9, …\n$ elev_low                      <dbl> -0.4, 2.4, 4.6, 12.8, 20.0, 68.3, 45.1, …\n$ end_latlng1                   <dbl> 50.15009, 50.00123, 50.15008, 50.15007, …\n$ end_latlng2                   <dbl> -5.084491, -5.181100, -5.084519, -5.0845…\n$ external_id                   <chr> \"garmin_ping_260217768521\", \"garmin_ping…\n$ flagged                       <chr> \"FALSE\", \"FALSE\", \"FALSE\", \"FALSE\", \"FAL…\n$ from_accepted_tag             <chr> \"FALSE\", \"FALSE\", \"FALSE\", \"FALSE\", \"FAL…\n$ gear_id                       <chr> \"b11291030\", \"b11291030\", \"b11291030\", \"…\n$ has_heartrate                 <chr> \"TRUE\", \"TRUE\", \"TRUE\", \"FALSE\", \"TRUE\",…\n$ has_kudoed                    <chr> \"FALSE\", \"FALSE\", \"FALSE\", \"FALSE\", \"FAL…\n$ heartrate_opt_out             <chr> \"FALSE\", \"FALSE\", \"FALSE\", \"FALSE\", \"FAL…\n$ id                            <dbl> 8566326572, 8541744691, 8531882051, 8527…\n$ kilojoules                    <dbl> 494.9, 595.4, 944.1, 76.5, 159.9, NA, NA…\n$ kudos_count                   <dbl> 17, 23, 14, 5, 2, 8, 27, 5, 26, 4, 11, 1…\n$ location_country              <chr> \"United Kingdom\", \"United Kingdom\", \"Uni…\n$ manual                        <chr> \"FALSE\", \"FALSE\", \"FALSE\", \"FALSE\", \"FAL…\n$ map.id                        <chr> \"a8566326572\", \"a8541744691\", \"a85318820…\n$ map.resource_state            <dbl> 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2…\n$ map.summary_polyline          <chr> \"a|aqHhu_^Uo@KmCOcAWo@kCwDYb@oBlEcDlC}D|…\n$ max_heartrate                 <chr> \"157\", \"150\", \"157\", NA, \"149\", \"166\", \"…\n$ max_speed                     <dbl> 57.0096, 58.2696, 66.5136, 58.8420, 41.0…\n$ moving_time                   <dbl> 3673, 3800, 6345, 757, 1158, 1878, 4314,…\n$ name                          <chr> \"Afternoon Ride\", \"Morning Ride. Fun unt…\n$ photo_count                   <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ pr_count                      <chr> \"0\", \"1\", \"8\", \"0\", \"0\", \"0\", \"7\", \"0\", …\n$ private                       <chr> \"FALSE\", \"FALSE\", \"FALSE\", \"FALSE\", \"FAL…\n$ resource_state                <dbl> 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2…\n$ sport_type                    <chr> \"Ride\", \"Ride\", \"Ride\", \"Ride\", \"Ride\", …\n$ start_date                    <chr> \"2023-02-15T16:04:05Z\", \"2023-02-11T10:0…\n$ start_date_local              <chr> \"2023-02-15T16:04:05Z\", \"2023-02-11T10:0…\n$ start_latlng1                 <dbl> 50.15005, 50.15006, 50.14998, 50.17089, …\n$ start_latlng2                 <dbl> -5.084534, -5.084494, -5.084516, -5.1274…\n$ suffer_score                  <chr> \"29\", \"30\", \"40\", NA, \"9\", \"33\", \"86\", \"…\n$ timezone                      <chr> \"(GMT+00:00) Europe/London\", \"(GMT+00:00…\n$ total_elevation_gain          <dbl> 376.0, 372.0, 601.0, 38.0, 147.0, 15.0, …\n$ total_photo_count             <dbl> 2, 3, 0, 0, 0, 0, 3, 0, 3, 0, 3, 0, 5, 3…\n$ trainer                       <chr> \"FALSE\", \"FALSE\", \"FALSE\", \"FALSE\", \"FAL…\n$ type                          <chr> \"Ride\", \"Ride\", \"Ride\", \"Ride\", \"Ride\", …\n$ upload_id                     <chr> \"9196267205\", \"9168807862\", \"9157876592\"…\n$ upload_id_str                 <chr> \"9196267205\", \"9168807862\", \"9157876592\"…\n$ utc_offset                    <chr> \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", …\n$ visibility                    <chr> \"everyone\", \"everyone\", \"everyone\", \"eve…\n$ workout_type                  <chr> \"10\", \"10\", NA, NA, NA, NA, \"0\", NA, \"0\"…\n$ average_cadence               <chr> NA, NA, NA, NA, NA, \"79.5\", \"81.3\", \"80.…\n$ location_city                 <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ location_state                <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n```\n:::\n:::\n\n\nThere are so many columns here, so I remove some columns I am not interested in for this post and do some data transformations to get the date in a correct format. I also do not want to run the example on all my rides, instead I filter them for just 2020. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# columns to keep\ndesired_columns <- c('distance', 'elapsed_time', 'moving_time', 'start_date', 'start_date_local', 'type', 'map.summary_polyline', 'location_city', 'upload_id')\n\n# keep only desired columns\nmy_acts2 <- dplyr::select(my_acts, any_of(desired_columns))\n\n# transformations ####\nmy_acts <- mutate(my_acts,\n                  activity_no = seq(1,n(), 1),\n                  elapsed_time = elapsed_time/60/60,\n                  moving_time = moving_time/60/60, \n                  date = gsub(\"T.*$\", '', start_date) %>%\n                    as.POSIXct(., format = '%Y-%m-%d'),\n                  EUdate = format(date, '%d/%m/%Y'),\n                  month = format(date, \"%m\"),\n                  day = format(date, \"%d\"),\n                  year = format(date, \"%Y\")) %>%\n  mutate(., across(c(month, day), as.numeric)) %>%\n  filter(.,year == '2020')\n```\n:::\n\n\n## Get latitude and longitude for each activity\n\nEach activity has a bunch of data associated with it. For mapping, I am interested in the `map.summary_polyline`, which is a Google polyline which allows the encoding of multiple latitude and longitude points as a single string. We can get the latitude and longitude for each of the activities by using `get_latlon()` which decodes the polylines and using dplyr and purrr to iterate over every activity in the dataframe. I add my Google API key as a column so that `map()` can easily find it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get lat lon and distance of every ride ####\nlat_lon <- my_acts %>%\n  filter(!is.na(map.summary_polyline)) %>%\n  filter(type == 'Ride') %>%\n  mutate(key = GoogleAPI) %>%\n  group_by(activity_no) %>%\n  nest() %>%\n  mutate(coords = map(data, ~get_latlon(.$map.summary_polyline, key = .$key)),\n         dist = map(coords, ~get_dists(.x$lon, .x$lat))) %>%\n  unnest(., data) %>%\n  unnest(., c(coords, dist))\n```\n:::\n\n\nHaving got the latitude and longitude for every ride, we can now get the elevation of each point and then calculate the gradient between points. To do this I use `elevation()` in the R package **rgbif**. To use this, you need to get a GeoNames username by registering for an account at [http://www.geonames.org/login ](http://www.geonames.org/login ).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get elevation and calculate gradient between points\nlat_lon <- ungroup(lat_lon) %>%\n  mutate(., ele = rgbif::elevation(latitude = .$lat, longitude = .$lon, user = 'YOUR USERNAME HERE', model = 'srtm1')$elevation_geonames)\n\nlat_lon <- group_by(lat_lon, activity_no) %>%\n  mutate(., ele_diff = c(0, diff(ele)),\n         dist_diff = c(0, diff(dist)),\n         grad = c(0, (ele_diff[2:n()]/10)/dist_diff[2:n()])) %>%\n  ungroup() %>%\n  dplyr::select(., -c(ele_diff, dist_diff))\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nThis now gives us a data frame of all my rides from 2020 with the latitude, longitude, cumulative distance, elevation and gradient. It would now be super easy to create elevation profiles, but I will save that for another post.\n\n## Create a gif of a single ride\n\nWe now have almost all the components to create a gif of a single ride.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlat_lon_single <- filter(lat_lon, activity_no == min(activity_no))\nnrow(lat_lon_single)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 343\n```\n:::\n:::\n\n\nHowever, Google polylines do not give a consistent number of latitude and longitude points. This means it might be hard to get a smooth elevation profile for the ride and also for smooth transitions in a gif. To create a set number of points from the current polyline, we can use geospatial packages such as **sp** and **raster** to interpolate a desired number of points from the current ones. Here I create 250 points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# reorder columns so lat lon are first\nlat_lon_single <- dplyr::select(lat_lon_single, lat, lon, everything())\n\n# make new data with by interpolation\ninterp <- raster::spLines(as.matrix(lat_lon_single[,1:2])) %>%\n  sp::spsample(., n = 250, type = 'regular') %>%\n  data.frame() %>%\n  mutate(., dist = get_dists(lon, lat),\n         ele = rgbif::elevation(latitude = .$lat, longitude = .$lon, user = 'padpadpadpad', model = 'srtm1')$elevation_geoname,\n         ele_diff = c(0, diff(ele)),\n         dist_diff = c(0, diff(dist)),\n         grad = c(0, (ele_diff[2:n()]/10)/dist_diff[2:n()]),\n         n = row_number())\n```\n:::\n\n\nWe can now put the gif together, using **ggmap** and **ggplot2**. We use **gganimate** to make the plot animated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# make bbox\nbbox <- ggmap::make_bbox(lon, lat, data = lat_lon_single, f = 1.3)\n\n# download map\nmap <- get_map(location = bbox, source = 'google', maptype = 'terrain')\n\nsingle_ride <- ggmap(map, darken = 0.15) +\n  geom_path(aes(x = lon, y = lat,  col = grad, group = 1), data = interp, size = 2, alpha = 1) +\n  scale_color_distiller('Gradient (%)', palette = 'Spectral') +\n  labs(title = '') +\n  coord_cartesian() +\n  ggforce::theme_no_axes(theme_bw(base_size = 16)) +\n  transition_reveal(dist)\n\n# animate plot\ngganimate::anim_save('where_to_save.gif', single_ride, width = 1000, height = 700)\n```\n:::\n\n\nThe output of this code can be seen below.\n\n![](/posts/animate_rstrava/single_ride.gif)\n\n## Create a gif of ALL the rides\n\nWe can also make a gif of multiple activities. I will filter my activities to only be bike rides over 15km.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get a bbox for Cornwall\nbbox <- ggmap::make_bbox(lat_lon_single$lon, lat_lon_single$lat, f = 1.2)\n\n# add column for frame and total distance per ride\nlat_lon <- group_by(lat_lon, activity_no) %>%\n  mutate(n = 1:n(),\n         tot_dist = max(distance)) %>%\n  ungroup()\n\n# filter lat_lon for when points are within this\nlat_lon <- filter(lat_lon, between(start_longitude, bbox[1], bbox[3]) & between(start_latitude, bbox[2], bbox[4]) & type == 'Ride' & tot_dist > 15)\n\n# add column for frame\nlat_lon <- group_by(lat_lon, activity_no) %>%\n  mutate(n = 1:n()) %>%\n  ungroup()\n\n# make bbox again\nbbox <- ggmap::make_bbox(lon, lat, data = lat_lon, f = 0.1)\n\n# download map\nmap <- get_map(location = bbox, source = 'google', maptype = 'terrain')\n\nall_the_rides <- ggmap(map, darken = 0.15) +\n  geom_path(aes(x = lon, y = lat, group = activity_no), col = 'red', data = lat_lon, size = 1.25, alpha = 0.5) +\n  labs(title = 'All the rides') +\n  coord_cartesian() +\n  ggforce::theme_no_axes(theme_bw(base_size = 16)) +\n  theme(legend.position = 'none') +\n  transition_reveal(n)\n\n# animate plot\ngganimate::anim_save('where_to_save.gif', all_the_rides, width = 750, height = 700)\n```\n:::\n\n\n![](/posts/animate_rstrava/all_the_rides.gif)\n\nAnd there we have it. A relatively simple way to animate your strava activities in R. I personally find that saving the output as .mp4 rather than .gif gives smaller and higher quality files when uploading them to Instagram, but these options are easy to change. Take back your own data and get plotting!\n\nThere are loads of other functions and uses for the **rStrava** package. I hope to blog more about them soon.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}