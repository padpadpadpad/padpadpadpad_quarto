{
  "hash": "698bbbf131b335bbc645948fe87bb23c",
  "result": {
    "markdown": "---\ntitle: Rolling regression to estimate microbial growth rate\ndescription: |\n  Calculating microbial growth rates from OD measurements using rolling regression in the tidyverse\nauthor: Daniel Padfield\ndate: '2019-11-15'\ncategories: \n  - R\n  - bacteria\nimage: /posts/rolling_regression/preview.png\n---\n\n\n### Introduction\n\nMicrobial ecologists often measure the growth rates of their favourite microbes, commonly using an OD (optical density) reader, with growth being related to the increasing OD of the sample through time. There are loads of ways to analyse these curves. Most of these, like [__growthcurver__](https://github.com/sprouffske/growthcurver) and the methods I used in my recent [ISME](https://github.com/padpadpadpad/Padfield_2019_ISME_bact_phage_temperature) paper ([__nls.multstart__](https://github.com/padpadpadpad/nls.multstart) and functions from [__nlsMicrobio__](https://cran.r-project.org/web/packages/nlsMicrobio/nlsMicrobio.pdf)), fit models to logistic growth. Both methods can easily be scaled up to fit multiple curves at the same time.\n\nHowever, sometimes these methods do not do a good job. The most common example when this happens is if the wee critters do not reach stationary phase. Without stationary phase, most of the models will struggle to calculate carrying capacity, which also means the estimated exponential growth rate is poor. Similar things can occur if the bacteria form biofilms. This can result in increasingly noisy measurements at higher OD readings, again making the estimation of carrying capacity and growth rates more difficult.\n\nAs an alternative, we can bin off trying to model the entire growth curve, and instead implement a rolling regression, where we fit a linear regression on a shifting window of points. On natural-log transformed OD, the slope of the regression between $logOD$ and time is equivalent to the exponential growth rate.\n\n### Get started\n\nWe will load (and install) all the packages needed to run the example here. We will use the example data from __growthcurver__ as example OD readings from a 96-well plate. Time is in hours, and I have created stacked all the wells into a single column for OD. Finally I created a column for $logOD$, which is needed for the rolling regression, and $log_{10}OD$ which is needed for fitting the modified gompertz growth model from __nlsMicrobio__.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load packages\nlibrary(tidyverse) #install.packages(tidyverse)\nlibrary(zoo) #install.packages(zoo)\nlibrary(broom) #install.packages(broom)\nlibrary(growthcurver) # install.packages(growthcurver)\nlibrary(nls.multstart) # install.packages(nls.multstart)\n# remotes::install_github('padpadpadpad/MicrobioUoE)\n\n# load example data\nd <- growthcurver::growthdata %>%\n  gather(., well, od, -time) %>%\n  mutate(ln_od = log(od),\n         log10_od = log10(od))\n# have a look at the data\nglimpse(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 13,920\nColumns: 5\n$ time     <dbl> 0.0000000, 0.1666667, 0.3333333, 0.5000000, 0.6666667, 0.8333…\n$ well     <chr> \"A1\", \"A1\", \"A1\", \"A1\", \"A1\", \"A1\", \"A1\", \"A1\", \"A1\", \"A1\", \"…\n$ od       <dbl> 0.05348585, 0.04800336, 0.05587451, 0.05131749, 0.04516719, 0…\n$ ln_od    <dbl> -2.928338, -3.036484, -2.884647, -2.969724, -3.097384, -2.938…\n$ log10_od <dbl> -1.271761, -1.318728, -1.252786, -1.289735, -1.345177, -1.276…\n```\n:::\n:::\n\n\n### Fit modified gompertz model for bacterial growth\n\nWe will first demonstrate rolling regression against the modified gompertz model for growth. I like the inclusion of the lag parameter in this model, especially for OD readers where the initial inoculate can often be so low that the OD reader cannot measure it. It means that exponential growth is only calculated at OD readings that we are confident represent changes in biomass of the bacteria.\n\nTo do this, we'll filter the data for just the first well, A1. Then we will fit the modified gompertz model and plot the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# filter for just a single well\nd_a1 <- filter(d, well == 'A1')\n# define gompertz growth model\ngompertz <- function(log10_nmax, log10_n0, mumax, t, lag){\n  log10_n0 + (log10_nmax - log10_n0) * exp(-exp(mumax * exp(1) * (lag - t)/((log10_nmax - log10_n0) * log(10)) + 1))\n}\n# fit gompertz model\nfit_gomp <- nls.multstart::nls_multstart(log10_od ~ gompertz(log10_nmax, log10_n0, mumax, t = time, lag),\n           data = d_a1,\n           start_lower = c(log10_nmax = -0.75, log10_n0 = -3, mumax = 0, lag = 0),\n           start_upper = c(log10_nmax = 0.5, log10_n0 = -1, mumax = 10, lag = 25),\n           lower = c(log10_nmax = -0.6, log10_n0 = -2, mumax = 0, lag = 0),\n           iter = 500,\n           supp_errors = 'Y')\n# get predictions\ngomp_preds <- augment(fit_gomp)\n# plot on original scale\nggplot(d_a1, aes(time, od)) +\n  geom_line(aes(time, 10^.fitted), gomp_preds, col = 'red') +\n  geom_point() +\n  theme_bw(base_size = 16) +\n  labs(x = 'time (hours)',\n       y = 'OD') +\n  annotate(geom = 'text', x = 0, y = 0.37, label = paste('µ = ', round(coef(fit_gomp)[3], 2), ' hr-1', sep = ''), hjust = 0, size = MicrobioUoE::pts(16))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot_gompz-1.png){width=768}\n:::\n:::\n\n\nHowever, lets say our measurements end at 10 or 11 hours. When we have not reached stationary phase, the traditional bacterial growth models are likely to have trouble fitting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_a1 <- filter(d_a1, time < 10.5)\n# plot data without stationary phase\nggplot(d_a1, aes(time, od)) +\n  geom_point() +\n  theme_bw(base_size = 16) +\n  labs(x = 'time (hours)',\n       y = 'OD')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot_short-1.png){width=768}\n:::\n:::\n\n\n### Using rolling regression\n\nRolling regression allows us to calculate exponential growth rate even when we do not have the whole curve. First, we need to create our own rolling regression function. This method is mainly taken from G. Grothendieck's [StackOverflow answer](https://stackoverflow.com/questions/49762128/rolling-regression-by-group-in-the-tidyverse). In the function, we specify our output from a standard __lm__ object. So if you know how to access the output of __lm()__, you can add any extra details you want.\n\nOne of the big decisions in rolling regression is deciding how many points you are going to calculate the growth rate over. In this example, measurements are taken every 0.167 hours, about every ten minutes. I want a shifting window to span a minimum of 1.5 hours, so I calculate `num_points` to define the number of points the rolling regression will act on.\n\nWe then run the rolling regression, using __zoo::rollapplyr()__ and __dplyr::do()__. Finally, in order to illustrate what the rolling regression is doing, I created a predictions dataframe for every single linear model that is fitted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create the rolling regression function\nroll_regress <- function(x){\n  temp <- data.frame(x)\n  mod <- lm(temp)\n  temp <- data.frame(slope = coef(mod)[[2]],\n                     slope_lwr = confint(mod)[2, ][[1]],\n                     slope_upr = confint(mod)[2, ][[2]],\n                     intercept = coef(mod)[[1]],\n                     rsq = summary(mod)$r.squared, stringsAsFactors = FALSE)\n  return(temp)\n}\n# define window - here every ~1.5 hours\nnum_points = ceiling(1.5*60/(60*0.167)) \n\n# run rolling regression on ln od ~ time\nmodels <- d_a1 %>%\n  do(cbind(model = dplyr::select(., ln_od, time) %>% \n           zoo::rollapplyr(width = num_points, roll_regress, by.column = FALSE, fill = NA, align = 'center'),\n           time = dplyr::select(., time),\n           ln_od = dplyr::select(., ln_od))) %>%\n  rename_all(., gsub, pattern = 'model.', replacement = '')\n# create predictions\npreds <- models %>%\n  filter(., !is.na(slope)) %>%\n  group_by(time) %>%\n  do(data.frame(time2 = c(.$time - 2, .$time + 2))) %>%\n  left_join(., models) %>%\n  mutate(pred = (slope*time2) + intercept)\n```\n:::\n\nWe can plot the rolling regression through time. I have extracted the exponential growth rate as the maximum slope of any of the regressions. Reassuringly the value of $\\mu$ we get is very similar to that of using the gompertz model. I have also plotted the time at which the maximum slope occurred. It looks pretty close to mid-log to me.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate the exponential growth rate\ngrowth_rate <- filter(models, slope == max(slope, na.rm = TRUE))\n# plot rolling regression\nggplot(d_a1, aes(time, ln_od)) +\n  geom_point() +\n  geom_line(aes(time2, pred, group = time), col = 'red', preds, alpha = 0.5) +\n  theme_bw(base_size = 16) +\n  geom_segment(aes(x = time, y = -3, xend = time, yend = ln_od), growth_rate) +\n  geom_segment(aes(x = 0, y = ln_od, xend = time, yend = ln_od), growth_rate) +\n  annotate(geom = 'text', x = 0, y = -1, label = paste('µ = ', round(growth_rate$slope, 2), ' hr-1\\n95%CI:(',round(growth_rate$slope_lwr, 2), '-', round(growth_rate$slope_upr, 2), ')', sep = ''), hjust = 0, size = MicrobioUoE::pts(16)) +\n  labs(x = 'time (hours)',\n       y = 'OD')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-1.png){width=768}\n:::\n:::\n\n\n### The opportunities are endless\n\nThe great thing about this approach is its flexibility. It can easily be rolled out over all the wells in that plate, using __group_by()__.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# run rolling regression on ln od_cor ~ time\nmodels <- d %>%\n  group_by(well) %>%\n  do(cbind(model = select(., ln_od, time) %>% \n           zoo::rollapplyr(width = num_points, roll_regress, by.column = FALSE, fill = NA, align = 'center'),\n           time = select(., time),\n           ln_od = select(., ln_od))) %>%\n  rename_all(., gsub, pattern = 'model.', replacement = '')\n# calculate growth rate for each one\ngrowth_rates <- models %>%\n  filter(slope == max(slope, na.rm = TRUE)) %>%\n  ungroup()\n```\n:::\n\n```\n|===========================================|100% ~0 s remaining \n```\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(models)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 13,920\nColumns: 8\nGroups: well [96]\n$ well      <chr> \"A1\", \"A1\", \"A1\", \"A1\", \"A1\", \"A1\", \"A1\", \"A1\", \"A1\", \"A1\", …\n$ slope     <dbl> NA, NA, NA, NA, -0.077427705, -0.028208492, -0.021245636, 0.…\n$ slope_lwr <dbl> NA, NA, NA, NA, -0.199773163, -0.160658493, -0.157480637, -0…\n$ slope_upr <dbl> NA, NA, NA, NA, 0.04491775, 0.10424151, 0.11498936, 0.131953…\n$ intercept <dbl> NA, NA, NA, NA, -2.944791, -2.976248, -2.967393, -3.024750, …\n$ rsq       <dbl> NA, NA, NA, NA, 0.2423791383, 0.0349643445, 0.0190560342, 0.…\n$ time      <dbl> 0.0000000, 0.1666667, 0.3333333, 0.5000000, 0.6666667, 0.833…\n$ ln_od     <dbl> -2.928338, -3.036484, -2.884647, -2.969724, -3.097384, -2.93…\n```\n:::\n:::\n\n\nThese growth rates can then be used for downstream analyses, and the method can easily be used over multiple plates and for many different types of data. Finally, you could also filter the regressions by $R^{2}$ values, making sure you only kept good fitting regressions. Or do a sensitivity analysis of different sized window sizes to make sure your chosen window is suitable.\n\nHow do you get your data off of the OD reader? I have written scripts to collate hundreds of plate readings into a single dataframe in R. Let me know if you would like me to do a blog post on that process! Thanks for reading.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}